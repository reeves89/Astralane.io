# ğŸŒŒ Astralane.io ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ (Japanese)

## ã‚¢ã‚¹ãƒˆãƒ©ãƒ¬ãƒ¼ãƒ³ã¸ã‚ˆã†ã“ã  
### ã‚¹ãƒ”ãƒ¼ãƒ‰æ™‚ä»£ã«å‘ã‘ã¦ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³æ€§èƒ½ã‚’é©æ–°ã™ã‚‹

ã‚¢ã‚¹ãƒˆãƒ©ãƒ¬ãƒ¼ãƒ³ã¯ã€Solanaã‚¤ãƒ³ãƒ•ãƒ©ã®è¤‡é›‘ãªä½œæ¥­ã‚’å¼•ãå—ã‘ã€ã‚ãªãŸãŒã‚¤ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã«é›†ä¸­ã§ãã‚‹ç’°å¢ƒã‚’æä¾›ã—ã¾ã™ã€‚  
ã‚°ãƒ­ãƒ¼ãƒãƒ«RPCã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã€è¶…é«˜é€Ÿãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ãƒ”ãƒ¼ãƒ‰ã€ãã—ã¦ãŠå®¢æ§˜ã®ãƒ‹ãƒ¼ã‚ºã«å¿œã˜ãŸã‚«ã‚¹ã‚¿ãƒ ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚Šã€ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼·åŠ›ã«ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

> **ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰ã¯ç§ãŸã¡ã«ä»»ã›ã¦ã€ã‚ãªãŸã¯ä¸–ç•Œã‚’å¤‰ãˆã‚‹ã“ã¨ã«é›†ä¸­ã—ã¾ã—ã‚‡ã†ï¼**

---

## ğŸš… ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ â€” ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

æœ€å°é™ã®ãƒ¯ã‚¤ãƒ¤é…å»¶ã‚’æ±‚ã‚ã‚‹HFTï¼ˆé«˜é »åº¦å–å¼•ï¼‰äº‹æ¥­è€…ã‹ã‚‰ã€ãƒ”ãƒ¼ã‚¯æ™‚ã«ã‚‚ç¢ºå®Ÿãªç´„å®šã‚’æ±‚ã‚ã‚‹ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ¡ãƒ¼ã‚«ãƒ¼ã¾ã§ã€  
Solanaä¸Šã§æœ€ã‚‚è¦æ±‚ã®å³ã—ã„ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ã‘ã«ã€ã‚¹ãƒ­ãƒƒãƒˆä»¥ä¸‹ã®é€Ÿåº¦ã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¼æ’­ã™ã‚‹ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ãªã‚¤ãƒ³ãƒ•ãƒ©ã‚’æä¾›ã—ã¾ã™ã€‚

ãƒªãƒ¼ãƒ€ãƒ¼ãƒ‘ã‚¹ã®æœ€é©åŒ–ã«åŠ ãˆã€ãƒã‚¤ãƒŠãƒªæœ€é©åŒ–ã•ã‚ŒãŸãƒ¡ãƒƒã‚·ãƒ¥ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚Šã€  
ã‚¹ãƒ­ãƒƒãƒˆæœªæº€ã®ç²¾å¯†ãªãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

ã•ã‚‰ã«ã€å‹•çš„ãªå„ªå…ˆé †ä½ã‚·ã‚¹ãƒ†ãƒ ãŒé«˜å„ªå…ˆåº¦ã®ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã«ãƒªã‚½ãƒ¼ã‚¹ã‚’å‰²ã‚Šå½“ã¦ã€  
ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ã®ä¿¡é ¼æ€§ã¨24æ™‚é–“365æ—¥ã®ã‚µãƒãƒ¼ãƒˆä½“åˆ¶ã§ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚

---

## ğŸš… ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨è¨­å®š â€” ç¨¼åƒã«å¿…è¦ãªã™ã¹ã¦ãŒã“ã“ã«

### ğŸ”— **ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: Irisï¼ˆã‚¢ã‚¤ãƒªã‚¹ï¼‰**
ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼š

- ãƒ•ãƒ©ãƒ³ã‚¯ãƒ•ãƒ«ãƒˆ: `http://fr.gateway.astralane.io/iris?api-key=xxxx`
- æ±äº¬: `http://jp.gateway.astralane.io/iris?api-key=xxxx`
- ãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯: `http://ny.gateway.astralane.io/iris?api-key=xxxx`

---

### ğŸ”­ **Paladinï¼ˆãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ï¼‰ãƒªãƒ¼ãƒ€ãƒ¼ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°**
- ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: `http://fr.gateway.astralane.io/api/paladin`

#### åˆ©ç”¨å¯èƒ½ãªAPIã‚³ãƒ¼ãƒ«:
- `sendTransaction`  
- `sendBundle`  
- `sendIdeal`  
- `getNonce`  
- `sendPaladin`

---

## ğŸ’¸ ãƒãƒƒãƒ—ç”¨ã‚¢ãƒ‰ãƒ¬ã‚¹

astrazznxsGUhWShqgNtAdfrzP2G83DzcWVJDxwV9bF
astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm
astra9xWY93QyfG6yM8zwsKsRodscjQ2uU2HKNL5prk
astraRVUuTHjpwEVvNBeQEgwYx9w9CFyfxjYoobCZhL


---

## ğŸ“Š ãƒ¬ãƒ¼ãƒˆåˆ¶é™

| ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆTPS |
|----------------|----------------|
| Iris           | 5 TPS          |
| Paladin        | 1 TPS          |

> ğŸ’¬ è¿½åŠ TPSã‚„ã‚«ã‚¹ã‚¿ãƒ ãƒªãƒ™ãƒ¼ãƒˆãƒ—ãƒ©ãƒ³ãŒå¿…è¦ãªå ´åˆã¯ã€**Telegramã«ã¦ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚**

---

## ğŸ’° æœ€å°ãƒãƒƒãƒ—é¡

- **Iris ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**  
  å„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«æœ€ä½ `0.0001 SOL` ã®ãƒãƒƒãƒ—ã‚’è¨­å®šã—ã€  
  ãƒãƒƒãƒ—ã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã®ã‚·ã‚¹ãƒ†ãƒ é€é‡‘å‘½ä»¤ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

- **Paladin ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**  
  å„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«æœ€ä½ `0.00XX SOL` ã®ãƒãƒƒãƒ—ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

âœ… é«˜åº¦ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡è€…å‘ã‘ã«ã¯ã€**ã‚«ã‚¹ã‚¿ãƒ ä¾¡æ ¼è¨­å®šãƒ—ãƒ©ãƒ³**ã«ã‚ˆã‚Šã€  
æœ€å°ãƒãƒƒãƒ—é¡ã®å¼•ãä¸‹ã’ã‚„å…é™¤ãŒå¯èƒ½ãªæŸ”è»Ÿãªãƒ—ãƒ©ãƒ³ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ› ï¸ åŠ¹ç‡çš„ãªæ´»ç”¨æ–¹æ³•

Paladin Leader API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã€**ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒªãƒ¼ãƒ€ãƒ¼ã¨ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°**ã‚’è¿½è·¡ã—ã¾ã—ã‚‡ã†ã€‚  
ã“ã‚Œã«ã‚ˆã‚Šã€**ãƒãƒƒãƒ—ã‚„æ‰‹æ•°æ–™ã‚’é©åˆ‡ã«èª¿æ•´**ã—ã€ã‚³ã‚¹ãƒˆã‚’æœ€é©ã«ç®¡ç†ã§ãã¾ã™ã€‚  
å¿…è¦ã«å¿œã˜ã¦ã€**å°‚ç”¨ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆçµŒç”±ã§è¨­å®šã‚’æ›´æ–°**ã—ã¦ãã ã•ã„ã€‚

---
ğŸš€ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€ä¿¡
ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€ä¿¡æ–¹æ³•
Astralane ã¯ã€ãŠå®¢æ§˜ã®ãƒ‹ãƒ¼ã‚ºã«åˆã‚ã›ã¦ã•ã¾ã–ã¾ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ç”¨ã«æä¾›ã—ã¦ã„ã‚‹ RPC ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸€éƒ¨ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

sendTransaction
ã“ã® RPC å‘¼ã³å‡ºã—ã¯ã€ã™ã¹ã¦ã® Solana ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨å®Œå…¨ã«äº’æ›æ€§ãŒã‚ã‚‹ãŸã‚ã€æ—¢å­˜ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ç°¡å˜ã«ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Jito ã‚„ Paladin (ã‚ˆã‚Šé«˜ã„æœ€å°ãƒãƒƒãƒ—) ãªã©ã®ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã® SWQoS ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä»‹ã—ã¦ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã•ã‚Œã‚‹ãŸã‚ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ãŒæœ€é©åŒ–ã•ã‚Œã€ä¿¡é ¼æ€§ãŒæœ€å¤§é™ã«é«˜ã¾ã‚Šã¾ã™ã€‚

RPC URL ã‚’é…ç½®ã™ã‚‹å ´æ‰€ã« URL ã‚’æŒ¿å…¥ã—ã€é€šå¸¸ã®é€ä¿¡æ–¹æ³•ã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã™ã‚‹ã ã‘ã§ã™ã€‚å¤‰æ›´ç‚¹ã¯ã€ãƒãƒƒãƒ—ã«å‘½ä»¤ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã ã‘ã§ã™ã€‚

const TIP: Pubkey = pubkey!("astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm"); // Use tip wallet depending on region of access
const MIN_TIP_AMOUNT: u64 = 100_000; // added for spam prevention

fn send_tx_tipped(
    ixs: &mut Vec<Instruction>, 
    signer: &Keypair, 
    rpc_client: &RpcClient
    ) {
    let tip_ix = system_instruction::transfer(&signer.pubkey(), &TIP, MIN_TIP_AMOUNT);
    ixs.push(tip_ix);

    let blockhash = rpc_client.get_latest_blockhash().unwrap();
    let tx = Transaction::new_signed_with_payer(ixs, Some(&signer.pubkey()), &[signer], blockhash);

    rpc_client.send_transaction(&tx).unwrap();
}

sendBundle
æ“ä½œãŒã‚¢ãƒˆãƒŸãƒƒã‚¯ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œã«ä¾å­˜ã—ã¦ã„ã‚‹å ´åˆã¯ã€sendBundle ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å®Ÿè¡Œã•ã‚Œã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã—ã¾ã™ã€‚

1 ã¤ã®ã‚¢ãƒˆãƒŸãƒƒã‚¯ ãƒãƒ³ãƒ‰ãƒ«ã§æœ€å¤§ 4 ã¤ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯é †ç•ªã«å®Ÿè¡Œã•ã‚Œã€ç²¾åº¦ã¨ä¿¡é ¼æ€§ãŒç¢ºä¿ã•ã‚Œã¾ã™ã€‚ã„ãšã‚Œã‹ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå¤±æ•—ã™ã‚‹ã¨ã€ãƒãƒ³ãƒ‰ãƒ«å…¨ä½“ãŒå…ƒã«æˆ»ã•ã‚Œã‚‹ãŸã‚ã€ä¸€è²«æ€§ãŒä¿è¨¼ã•ã‚Œã€éƒ¨åˆ†çš„ãªå¤±æ•—ãŒæ’é™¤ã•ã‚Œã¾ã™

//Rust

const TIP: Pubkey = pubkey!("astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm"); // Use tip wallet depending on region of access
const MIN_TIP_AMOUNT: u64 = 100_000; // added for spam prevention

async fn send_bundle(
    ixs: &mut Vec<Instruction>,
    signer: &Keypair,
    client: reqwest::Client,
    blockhash: Hash,
    url: String,
) {
    let tip_ix = system_instruction::transfer(&signer.pubkey(), &TIP, MIN_TIP_AMOUNT);
    ixs.push(tip_ix);
    let tx = Transaction::new_signed_with_payer(ixs, Some(&signer.pubkey()), &[signer], blockhash);
    let encoded_tx = base64::prelude::BASE64_STANDARD.encode(&bincode::serialize(tx).unwrap());
    let response = client
        .post(url)
        .header("api_key", "xxx")
        .json(&json! ({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "sendBundle",
            "params": [[encoded_tx]],
        }))
        .send()
        .await;
}

//Golang
package main

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/davecgh/go-spew/spew"
	"github.com/gagliardetto/solana-go/programs/system"
	"log"
	"net/http"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
)

func main() {
	payerPrivateKeyBase58 := "YOUR_WALLET_PRIVATE_KEY"
	astralaneTipAddressBase58 := "astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm"
	rpcEndpoint := "DM_US_FOR_TRIAL_RPC_ENDPOINTS"
	astralaneEndpoint := "http://fr.gateway.astralane.io/iris?api-key=YOUR_ASTRALANE_API_KEY"

	signer, err := solana.PrivateKeyFromBase58(payerPrivateKeyBase58)
	if err != nil {
		log.Fatalf("Failed to load private key: %v", err)
	}

	client := rpc.New(rpcEndpoint)
	recentBlockhash, err := client.GetLatestBlockhash(context.Background(), rpc.CommitmentFinalized)
	if err != nil {
		log.Fatalf("Failed to get recent blockhash: %v", err)
	}

	astralaneTipAddress, err := solana.PublicKeyFromBase58(astralaneTipAddressBase58)
	if err != nil {
		log.Fatalf("Failed to decode astralane tip address: %v", err)
	}
	tx, err := solana.NewTransaction(
		[]solana.Instruction{
			system.NewTransferInstruction(
				200_000,
				signer.PublicKey(),
				astralaneTipAddress,
			).Build(),
		},
		recentBlockhash.Value.Blockhash,
		solana.TransactionPayer(signer.PublicKey()),
	)
	if err != nil {
		log.Fatalf("Failed to create transaction: %v", err)
	}

	if _, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		return &signer
	}); err != nil {
		log.Fatalf("Failed to sign transaction: %v", err)
	}

	spew.Dump(tx)

	out, err := tx.MarshalBinary()
	if err != nil {
		log.Fatalf("Marshaling to binary failed: %v", err)
	}
	encodedTx := base64.StdEncoding.EncodeToString(out)

	decoded, err := base64.StdEncoding.DecodeString(encodedTx)
	if err != nil {
		log.Fatalf("Sanity check decode failed: %v", err)
	}
	if !bytes.Equal(decoded, out) {
		log.Fatalf("Sanity check failed: decoded transaction does not match original binary")
	}

	payload := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "sendBundle",
		"params": []interface{}{
			[]string{encodedTx},
		},
	}

	response, err := sendBundleRequest(astralaneEndpoint, payload)
	if err != nil {
		log.Fatalf("Bundle RPC failed: %v", err)
	}

	log.Printf("Bundle RPC response: %s", response)
}

func sendBundleRequest(endpoint string, payload map[string]interface{}) (string, error) {
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return "", fmt.Errorf("Failed to marshal JSON: %w", err)
	}

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Post(endpoint, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("Request to Bundle RPC failed: %w", err)
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", fmt.Errorf("Failed to decode Bundle RPC response: %w", err)
	}

	responseBytes, _ := json.MarshalIndent(result, "", "  ")
	return string(responseBytes), nil
}

//Request
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "sendBundle",
  "params": [
    "base64_encoded_txn1",
    "base64_encoded_txn2"
    "base64_encoded_txn3"
    {
      "encoding": "base64",
      "mevProtect": true
    }
  ]
}

//Response:
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": [
        "37Dxw2nJYw3T8JVqenPQMf39VJ9CNZYCyQm67b6nRj6fa6UjQ1UuLqFvh3wJ2G7LcMuZn4oq5kDt2A2CEXfi8D8"
    ]
}

// æ³¨æ„: MAX_TRANSACTIONS_IN_BUNDLE = 4
// ãƒãƒ³ãƒ‰ãƒ«å†…ã®æœ€å¤§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°ã¯4ã§ã™ã€‚

//sendIdeal
ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã«æœ€é©ã§ã™! JITO ãƒãƒªãƒ‡ãƒ¼ã‚¿ã¨é€šå¸¸ã®ãƒãƒªãƒ‡ãƒ¼ã‚¿ã«åˆ†é›¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã¯ JITO ãƒãƒƒãƒ—ã«å¤šãè²»ã‚„ã™ã‹ã€å„ªå…ˆæ‰‹æ•°æ–™ã«å¤šãè²»ã‚„ã™ã‹ã§è‘›è—¤ã™ã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚æ°¸ç¶šçš„ãª nonce ã¯ã€ã“ã®å•é¡Œã‚’è»½æ¸›ã™ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚

å½“ç¤¾ã® sendIdeal RPC ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€2 ã¤ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å—ã‘å…¥ã‚Œã¾ã™:

1 ã¤ã¯å„ªå…ˆåº¦ã®é«˜ã„æ‰‹æ•°æ–™ + æœ€å°ãƒãƒƒãƒ—

ã‚‚ã† 1 ã¤ã¯é«˜ã„ãƒãƒƒãƒ— + å„ªå…ˆåº¦ã®ä½ã„æ‰‹æ•°æ–™

ã“ã‚Œã‚‰ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€é«˜åº¦ãª SWQoS ãŠã‚ˆã³ãƒãƒ³ãƒ‰ãƒ« ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’ä»‹ã—ã¦ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚æ°¸ç¶šçš„ãª nonce ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€1 ã¤ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒåˆ°ç€ã™ã‚‹ã¨ã€ã‚‚ã† 1 ã¤ã¯è‡ªå‹•çš„ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã‚‹ãŸã‚ã€æœ€é©ãªåŠ¹ç‡ã¨ã‚³ã‚¹ãƒˆå‰Šæ¸›ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚

æ°¸ç¶šçš„ãª nonce ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è‡ªåˆ†ã§ç®¡ç†ã—ãŸããªã„å ´åˆã¯ã€ãã®ãŸã‚ã®ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚ä½¿ç”¨ã™ã‚‹ API ã‚­ãƒ¼ã”ã¨ã« nonce ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã€getNonce rpc å‘¼ã³å‡ºã—ã‚’ä½¿ç”¨ã—ã¦ã‚¯ã‚¨ãƒªã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã‚’æœ€å¤§é™ã«æ´»ç”¨ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®çµ±åˆæ‰‹é †ã«å¾“ã£ã¦ãã ã•ã„ã€‚

Step 1 : Generate Nonce instruction

//Rust 
use solana_sdk::hash::Hash;
use solana_sdk::pubkey::Pubkey;
use solana_sdk::signature::{EncodableKey, Keypair, Signer};

async fn get_nonce(
    client: reqwest::Client,
    url: String,
    auth_key: String,
) {
    let response = client
        .post(url)
        .header("api_key", "xxx")
        .json(&json! ({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getNonce",
            "params": [api_key], // provided during onboarding
        }))
        .send()
        .await;
    let result = response["result"].clone();
    let nonce = result["nonce"].as_str().unwrap();
    let nonce_account = Pubkey::from_str(result["nonceAccount"].as_str().unwrap()).unwrap();
    let nonce_authority =
        Pubkey::from_str(result["nonceAuthority"].as_str().unwrap()).unwrap();
    let nonce_as_hash = Hash::from_str(nonce).unwrap();
}

æ¬¡ã«ï¼ä»¥ä¸‹ã«ã€ŒsendIdealã€ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®TypeScriptã‚³ãƒ¼ãƒ‰ä¾‹ã‚’æ—¥æœ¬èªç¿»è¨³ã—ã¾ã—ãŸã€‚
import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL,
  ComputeBudgetProgram,
} from '@solana/web3.js';
import * as bs58 from 'bs58';


 async sendTransTest() {
    try {
      const result = await fetch(
        `http://fr.gateway.astralane.io/iris?api-key=<api-key>`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getNonce',
            params: [
              'api-key',
            ],
          }),
        },
      );
      const res = await result.json();
      const data = res as any;
      const nonceAccount = new PublicKey(data.result.nonceAccount);
      const nonceAuthority = new PublicKey(data.result.nonceAuthority);
      const nonce = data.result.nonce;
      const advanceNonce = SystemProgram.nonceAdvance({
        noncePubkey: nonceAccount,
        authorizedPubkey: nonceAuthority,
      });

      const secretKey = Keypair.fromSecretKey(
        bs58.default.decode(
          'wallet-private-key',
        ),
      );

      const wallet = secretKey;
      //Tip account
      const toPublicKey = new PublicKey(
        'astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm',
      );
      const MIN_TIP_AMOUNT = 100000;

      const lowTipHighFeeIx = [
        advanceNonce,
        ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: 1 * 100000,
        }),
        SystemProgram.transfer({
          fromPubkey: wallet.publicKey,
          toPubkey: toPublicKey,
          lamports: MIN_TIP_AMOUNT,
        }),
      ];

      const HighTipLowFeeIx = [
        advanceNonce,
        ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: 1 * 100,
        }),
        SystemProgram.transfer({
          fromPubkey: wallet.publicKey,
          toPubkey: toPublicKey,
          lamports: 100 * MIN_TIP_AMOUNT,
        }),
      ];

      const htlfTransaction = new Transaction().add(...HighTipLowFeeIx);
      htlfTransaction.recentBlockhash = nonce;
      htlfTransaction.feePayer = wallet.publicKey;
      htlfTransaction.partialSign(wallet);
      const highTipLowFeeEncoded = Buffer.from(
        htlfTransaction.serialize({
          requireAllSignatures: false,
          verifySignatures: false,
        }),
      ).toString('base64');

      const lthfTransaction = new Transaction().add(...lowTipHighFeeIx);
      lthfTransaction.recentBlockhash = nonce;
      lthfTransaction.feePayer = wallet.publicKey;
      lthfTransaction.partialSign(wallet);
      const lowTipHighFeeEncoded = Buffer.from(
        lthfTransaction.serialize({
          requireAllSignatures: false,
          verifySignatures: false,
        }),
      ).toString('base64');

      const final = await fetch(
        `http://fr.gateway.astralane.io/iris?api-key=<api-key>`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'sendIdeal',
            params: [[highTipLowFeeEncoded, lowTipHighFeeEncoded]],
          }),
        },
      );
      const finalResult = await final.json();
      console.log(finalResult);

      return lowTipHighFeeEncoded;
    } catch (error) {
      console.log(error);
    }
  }

  //Request
  {
  "id": 1,
  "jsonrpc": "2.0",
  "method": "sendIdeal",
  "params": [
    "transction_with_large_tip_low_priority_fee",
    "transaction_with_large_priority_fee_low_tip"
    {
      "encoding": "base64"
    }
  ]
}


//Response
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": [
        "<signature A>",
        "<signature B>"
    ]
}

//sendPaladin (ãƒ™ãƒ¼ã‚¿ç‰ˆ)
Paladin ã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒªãƒ¼ãƒ€ãƒ¼ã«ç›´æ¥é€ä¿¡ã™ã‚‹ãŸã‚ã®ã‚ˆã‚ŠåŠ¹ç‡çš„ãªæ–¹æ³•ã‚’æä¾›ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ  TPU ãƒãƒ¼ãƒˆå®Ÿè£…ã§ã™ã€‚Paladin ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ç¾åœ¨ã€Solana ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã® 10% ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã™ (2025 å¹´ 3 æœˆ 10 æ—¥ç¾åœ¨)

ã‚¹ãƒ†ãƒƒãƒ— 1: ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒªãƒ¼ãƒ€ãƒ¼ã®è¿½è·¡
ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã¯ã™ã¹ã¦ã®ã‚¹ãƒ­ãƒƒãƒˆã«å­˜åœ¨ã™ã‚‹ã‚ã‘ã§ã¯ãªã„ãŸã‚ã€ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒªãƒ¼ãƒ€ãƒ¼ãŒã„ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒªãƒ¼ãƒ€ãƒ¼ ãƒˆãƒ©ãƒƒã‚«ãƒ¼ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚ãƒªãƒ¼ãƒ€ãƒ¼æƒ…å ±ã«åŸºã¥ã„ã¦ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‹•çš„ã«é€ä¿¡ã™ã‚‹ãŸã‚ã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼çµ±åˆã«é–¢ã™ã‚‹ä¸€èˆ¬çš„ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚

ç¾åœ¨ã®ã‚¨ãƒãƒƒã‚¯ã®ã™ã¹ã¦ã® Palidator å…¬é–‹éµã‚’å–å¾—ã—ã¾ã™
âš”ï¸ GET /api/palidators
[
    "Ss...Z77",
    "ACv...mi",
    "7Z...Z84",
]

æ¬¡ã®ãƒ‘ãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ãƒªãƒ¼ãƒ€ãƒ¼ã‚¹ãƒ­ãƒƒãƒˆã‚’ç²å¾—
âš”ï¸ GET /api/next_palidator
{
  "pubkey": "Csd...def",
  "leader_slot": 42424242,
  "context_slot": 42424242
}

æŒ‡å®šã•ã‚ŒãŸã‚¹ãƒ­ãƒƒãƒˆä»¥é™ã«æ¬¡ã®ãƒªãƒ¼ãƒ€ãƒ¼ Palidator ã‚’ç²å¾—ã™ã‚‹
âš”ï¸ GET /api/next_palidator/{slot}
{
  "pubkey": "Csd...def",
  "leader_slot": 42424242,
  "context_slot": 42424242
}

æ³¨æ„: æ‚ªæ„ã®ã‚ã‚‹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ä¸­ã«ã¯ã€Paladin ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãµã‚Šã‚’ã™ã‚‹äººã‚‚ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®ã‚ˆã†ãªã‚·ãƒŠãƒªã‚ªã§æ‚ªç”¨ã•ã‚Œãªã„ã‚ˆã†ã«ã€æ‚ªæ„ã®ã‚ã‚‹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«å¯¾ã™ã‚‹ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ–ãƒ­ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹æ–¹æ³•ãŒã‚ã‹ã‚‰ãªã„å ´åˆã¯ã€Discord ã§ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚

Paladin ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã«é€ä¿¡ã•ã‚Œã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯ã€10 ãƒ©ãƒ³ãƒãƒ¼ãƒˆ/CU ã¨ã„ã†éå¸¸ã«å°ã•ãªæœ€å°åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚

ã‚¹ãƒ†ãƒƒãƒ— 2: ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä½œæˆ
ã“ã‚Œã‚‰ã®ã‚¹ãƒ­ãƒƒãƒˆä¸­ã«ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã™ã‚‹ã«ã¯ã€send_palladin ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã™ã‚‹éš›ã¯ã€æœ€å°ãƒãƒƒãƒ—è¦ä»¶ã¨æœ€å°å„ªå…ˆæ‰‹æ•°æ–™è¦ä»¶ã‚’å¿…ãšéµå®ˆã—ã¦ãã ã•ã„ã€‚

ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€ä¿¡ä¸­ã¯ã€2 ã¤ã®ãƒ¢ãƒ¼ãƒ‰ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚Fail on revert: True / False

ã“ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«é€ä¿¡ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€å°è¦æ¨¡ãªã‚ªãƒ¼ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€šéã—ã€é †åºã¯æ¬¡ã®åŸºæº–ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚

å„ªå…ˆæ‰‹æ•°æ–™

ã‚¿ã‚¤ãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã¯ã€Astralane ãƒãƒƒãƒ— ã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã®ãƒãƒƒãƒ—ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™

å‹è€…ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒãƒ¼ãƒˆçµŒç”±ã§é€ä¿¡ã•ã‚Œã¾ã™ã€‚failOnRevert: false ã®å ´åˆã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ªãƒ¼ã‚¯ã‚·ãƒ§ãƒ³ã«å‹ã¦ãªã‹ã£ãŸå ´åˆã€SwQOS / JITO çµŒç”±ã§é€ä¿¡ã•ã‚Œã¾ã™ã€‚

failOnRevert true ã®å ´åˆã€ã“ã‚Œã‚‰ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ Palidators ã«ã®ã¿é€ä¿¡ã•ã‚Œã€ã‚¹ãƒ­ãƒƒãƒˆãŒãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³ ãƒªãƒ¼ãƒ€ãƒ¼ã®è¿‘ãã«ãªã„å ´åˆã¯ç ´æ£„ã•ã‚Œã¾ã™ã€‚

{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "sendPaladin",
  "params": [
    "<base 64 tx>",
    {
      "failOnRevert": "false"
    }
  ]
}

{
    "jsonrpc": "2.0",
    "id": 1,
    "result": [
        "<signature A>",
    ]
}

ã“ã‚Œã‚’åŠ¹ç‡çš„ã«ä½¿ç”¨ã™ã‚‹ã«ã¯ã€Paladin Leader API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒªãƒ¼ãƒ€ãƒ¼ã¨ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¿½è·¡ã—ã€ãã‚Œã«å¿œã˜ã¦ãƒãƒƒãƒ—/æ–™é‡‘ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚æœ€é©ãªã‚³ã‚¹ãƒˆç®¡ç†ã®ãŸã‚ã«ã€å°‚ç”¨ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä»‹ã—ã¦æ§‹æˆã‚’æ›´æ–°ã—ã¦ãã ã•ã„ã€‚

---
## ğŸ†˜ ãŠå›°ã‚Šã§ã™ã‹ï¼Ÿ

æŠ€è¡“ã‚¬ã‚¤ãƒ‰ã€çµ±åˆã‚µãƒãƒ¼ãƒˆã€æœ€æ–°æƒ…å ±ã®å—ã‘å–ã‚Šã«ã¯ã€  
ğŸ‘‰ [**Discordã«ã”å‚åŠ ãã ã•ã„ã€‚**](https://discord.com/invite/2UfWGtUDtN)

---

> **Astralane â€” Solanaã‚¤ãƒ³ãƒ•ãƒ©ã®æœ€å‰ç·šã§ã€ã‚ãªãŸã®ãƒ“ãƒ«ãƒ‰ã‚’åŠ é€Ÿã™ã‚‹ã€‚**
